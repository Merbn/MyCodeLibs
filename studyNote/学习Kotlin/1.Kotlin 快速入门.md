# Java 和 Kotlin 语言对比
## 打印日志
+ Java
```
System.out.print("amit Sheckeer");
System.out.println("换行打印");
```
+ Kotlin
```
print("普通打印");
println("换行打印");
```
## 常量与变量
+ Java
```
String name ="merbng";
final String name ="merbng;
```
+ Kotlin
```
var name ="merbng"
val name ="merbng"
```
## null声明
+ Java
```
String otherName ;
otherName = null;
```
+ Kotlin
```
var otherName : String?
otherName = null
```
## 空判断
+ Java

```
if(text != null){
    int length =text.length();
}
```
+ Kotlin

```
text?.let{
    val length =text.length
}
```
## 字符串拼接
+ Java
```
    String firstName = "merbng";
    String lastName = "is";
    String message ="My name is "+firstName+" "+lastName;
```
+ Kotlin
```
val firstName = "merbng"
val lastName = "is"
val message = "My name is $firstName $lastName"
```
## 换行
+ Java
```
String text = "First line \n"+
               "Second line \n"+
               "Third line";
```
+ Kotlin
```
val text = """
        |First line
        |Second line
        |Third line
        """.trimMargin()
```
## 三元表达式
+ Java
```
String text =x>5?"x>5":"x<5";
```
+ Kotlin
```
val text = if(x>5)
            "x>5"
           else "x<=5"
```
## 类型判断和转换（声明式）
+ Java
```
if (object instanceof Car){

}
Car car =(Car)object;
```
+ Kotlin
```
if(object is Car){

}
var car =object as Car
```
## 类型判断和转换（隐式)
+ Java
```
if(object instanceof Car){
    Car car =(Car)object;
}
```
+ Kotlin
```
if(object is Car){
var car =object
}
```
## 多重条件
+ Java
```
if(score >=0 && score <=300){}
```
+ Kotlin
```
if(score in 0..300){}
```
## 更灵活的case语句
+ Java
```
int score =2;
String grade;
switch(score){
    case 10:
    case 9:
    grade ="Excellent"
        break;
    case 8:
    case 7:
    case 6:
    grade="Good"
        break;
    case 3:
    case 2:
    case 1:
    grade ="Fail"
        break;
    default:
     grade="Fail"
}
```
- Kotlin
```
var score =1
var grade =when(score){
    9,10->"Excellent"
    in 6..8 ->"Good"
    4,5 ->"OK"
    in 1..3 ->"Fail"
    else ->"Fail"
}
```
## for 循环
+ Java
```
for(int i =1; i<=10 ;i++){}
for(int i =1; i<10;i++){}
for(int i =10;i>=0;i--){}
for(int i =1;i<=10;i+=2){}
for(int 10;i>=0;i-=2){}
for(String item :collection){}
for(Map.Entry<String,String>entry : map.entrySet()){}
```
+ Kotlin
```
for(i in 1..10){}
for(i in 1 until 10){}
for(i in 10 downTo 0){}
for (i in 1..10 step 2){}
for( i in 10 downTo 1 step 2){}
for(item in collection){}
for((key,value) in map){}
```
## 更方便的集合操作
+ Java
```final List<Integer>listOfNumber =Arrays.asList(1,2,3,4);
   final Map<Integer,String>keyValue =new HashMap<Integer,String>();
   map.put(1,"merbng");
   map.put(2,"aelex");
   map.put(3,"xxxw");

   final List<Integer> listOfNumber =List.of(1,2,3,4);
   final Map<Integer,String>keyValue =Map.of(1,"nerb",2,"aelex",3,"xxxw");
```
+ Kotlin
```
val listOfNumber = listOf(1,2,3,4);
val keyValue =mapOf(1 to "merbng",
                    2 to "aelex",
                    3 to "xxxw")
```
## 遍历
+ Java
```
//java7 and below
for(Car car :cars){
    System.out.println(car.speed)
}
//java 8+
cars.forEach(car -> System.out.println(car.speed))
//java 7 and below
for(Car car :cars){
    if(car.speed>100){
        System.out.println(car.speed)
    }
}
//java 8 +
cars.stream().filter(car->car.speed>100).forEach(car->Sytem.out.println(car.speed))
```
+ Kotlin
```
cars.forEach{
    println(it.speed)
}
cars.filter{it.speed>100}
        .forEach{println(it.speed)}
```

## 方法定义

+ Java
```
void doSomething(){

}
void doSomething(int ... numbers){

}
```
+ Kotlin
```
fun doSomething(){
}
fun doSomething(vararg numbers:Int){
}

```
## 带返回值的方法
+ Java
```
int getScore(){
    return score;
}
```
+ Kotlin
```
fun getScore():Int{
    return score;
}
fun getScore :Int =score
```
## 无结束符号
+ Java
```
int getScore(int value){
    return 2*value;
}
```
+ Kotlin
```
fun getScore(int value):Int{
    return 2*value;
}
fun getScore(value:Int):Int=2*value;
```
## constructor构造器
+ Java
```
public class Utils {
    private Utils(){
    }
    public static int getScore(int value){
        return 2*value;
    }
}
```
+ Kotlin
```
class Utils private constructor(){
    companion object{
        fun getScore(value : Int):Int{
            return 2*value;
        }
    }
}
object Utils{
    fun getScore(value :Int):Int{
        return 2*value;
    }
}
```
## Get Set 构造器
+ Java
```
public class Developer{
    private String name;
    private int age;

    public Developer(String name,int age){
        this.name =name;
        this.age =age;
    }
    public String getName(){
        return name;
    }
    public void setName(String name){
        this.name =name;
    }
    public int getAge(){
        return age;
    }
    public void setAge(int age){
        this.age =age;
    }
        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;

            Developer developer = (Developer) o;

            if (age != developer.age) return false;
            return name != null ? name.equals(developer.name) : developer.name == null;

        }

        @Override
        public int hashCode() {
            int result = name != null ? name.hashCode() : 0;
            result = 31 * result + age;
            return result;
        }

        @Override
        public String toString() {
            return "Developer{" +
                    "name='" + name + '\'' +
                    ", age=" + age +
                    '}';
        }

}
```
+ Kotlin
```
data class Developer(val name:String ,val age:Int)
```
+ 函数定义
```fun sum(a:Int,b:Int):Int
{
    retunr a+b
}
```
+ 表达式作为函数体，返回类型自动推断：
```
fun sun(a:Int,a:Int)=a+b
public fun sum(a:Int,b:Int):Int =a+b //public方法必须明确写出返回类型
```
+ 无返回值的函数（类似java中的void）
```fun printSum(a:Int,b:Int):Unit{
    print(a+b)
}

//如果返回Unit类型，则可以省略，（对于public方法也是这样）：
public fun printSum(a:Int,b:Int){
    print(a+b)
}
```
+ 可变长参数函数
```函数的边长参数可以用vararg关键字进行标识：
fun vars(vararg v:Int){
    for(vt in v){
        print(vt)
    }
}
fun main(args:Array<String>){
    vars(1,2,3,4,5)
}
```
+ lambda（匿名函数）
```
fun main(args:Array<String>)
{ 
    val sumLambda:(Int,Int)->Int={x,y->x+y}
    println(sumLambda(1,2))//输出 3
}
```
+ 定义常量与变量
可变变量：var关键字
不可变变量：val ，只能赋值一次的变量（类似java中final修饰的变量）
常量与变量都可以没有初始化值，但是在引用前必须初始化
编译器支持自动类型判断，即声明时可以不指定类型，由编译器判断
val a:Int =1
val b=1 //系统自动推断变量类型为Int
val c:Int//如果不在声明初始化则必须提供变量类型
c =1 //明确赋值

var x= 5 //系统自动推断变量类型为Int
x +=1 //变量可修改

注释
Kotlin中的块注释允许嵌套

字符串模版
$表示一个变量名或者变量值
$varName表示变量值
${varName.fun()}表示变量的方法返回值
```
var a= 1
val s1 ="a is $a"
a =2
val s2 ="${s1.replace("is","was")},but now is $a"
```
+ NULL检查机制
Kotlin的空安全设计对于声明可为空的参数，在使用时要进行判断处理，有两种处理方式，
字段后加！！像java一样抛出空异常，另一种字段后加？ 可不做处理返回为null或配合？：做空判断处理
//类型后面加？ 表示可为空
var age:String? ="23"
//抛出空指针异常
val ages =age!!.toInt()
//age为空返回-1
val ages2 =age?.toInt()?:-1
当一个引用可能为null值时，对应的类型声明必须明确的标志为可为null
当str中的字符串内容不是一个整数时，返回null
fun parseInt(str:String):Int?{
    //...
}
如何使用一个返回值可为null的函数：
fun main(args:Array<String>){
    if(args.size<2){
        print("Two integer expected")
        return
    }
    val x =parseInt(args[0])
    val y =parseInt(args[1])
    //直接使用'x*y'会导致错误，因为他们可能为null
    if(x!=null&&y!=null){
       //在进行过null值检查之后，x和y的类型会被自动转换为null变量
       print(x*y)
    }
}
+ 类型检测及自动类型转换
fun getStringLength(obj:Any):Int?{
    if(obj is String){
    //做过类型判断以后，obj会被系统自动转换为String类型
        return obj.length
    }
    //在这里还有一种方法，与java中instanceof 不同，使用！is
     //if(obj !is String){
   //  
   //  }
   //这里的obj仍然是Any类型的引用
   return null
}
+ 区间
区间表达式由具有操作符形式..的rangeTo函数辅以in和！in形成
区间 是为任何可比较类型定义的，，但由于整型原生类型，他有一个优化的实现，
for(i in 1..4)print(i)
for(i in 4..1)print(i)
if(i in 1..10){
    println(i)
}
//使用step 指定步长
for(i in 1..4 step 2)print(i)
for(i in 4 downTo 1 step 2)print(i)
for(i in until 10){
print(i)
}





